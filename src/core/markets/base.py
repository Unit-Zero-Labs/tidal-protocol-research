#!/usr/bin/env python3
"""
Base market interface and market registry for the Tidal Protocol simulation.

This module implements the market plugin system where each market is an
independent component that can execute specific types of actions.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Set, Optional
from ..simulation.primitives import Action, Event, ActionKind, Asset


class BaseMarket(ABC):
    """Abstract base class for all DeFi markets"""
    
    def __init__(self, market_id: str):
        """
        Initialize market with unique identifier
        
        Args:
            market_id: Unique identifier for this market
        """
        self.market_id = market_id
        self.supported_actions: Set[ActionKind] = set()
    
    @abstractmethod
    def route(self, action: Action, simulation_state: Dict[str, Any]) -> List[Event]:
        """
        Execute action and return events
        
        Args:
            action: Action to execute
            simulation_state: Current simulation state (includes agent states)
            
        Returns:
            List of events generated by executing the action
        """
        pass
    
    @abstractmethod
    def end_of_block(self, simulation_state: Dict[str, Any]) -> List[Event]:
        """
        Handle end-of-block operations (interest accrual, rewards, etc.)
        
        Args:
            simulation_state: Current simulation state
            
        Returns:
            List of events generated by end-of-block operations
        """
        pass
    
    @abstractmethod
    def get_market_data(self) -> Dict[str, Any]:
        """
        Provide market-specific data for MarketSnapshot
        
        Returns:
            Dictionary containing market data
        """
        pass
    
    def supports_action(self, action_kind: ActionKind) -> bool:
        """Check if this market supports a specific action type"""
        return action_kind in self.supported_actions
    
    def validate_action(self, action: Action, simulation_state: Dict[str, Any]) -> tuple[bool, Optional[str]]:
        """
        Validate if an action can be executed
        
        Args:
            action: Action to validate
            simulation_state: Current simulation state
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        if not self.supports_action(action.kind):
            return False, f"Market {self.market_id} does not support action {action.kind}"
        
        return True, None
    
    def create_event(self, action: Action, result: Dict[str, Any], success: bool = True, error_message: Optional[str] = None) -> Event:
        """
        Helper method to create events
        
        Args:
            action: Original action
            result: Execution result
            success: Whether the action succeeded
            error_message: Error message if action failed
            
        Returns:
            Event object
        """
        return Event(
            action_kind=action.kind,
            agent_id=action.agent_id,
            market_id=self.market_id,
            result=result,
            success=success,
            error_message=error_message
        )


class MarketRegistry:
    """Central routing system for actions to markets"""
    
    def __init__(self):
        self.markets: Dict[str, BaseMarket] = {}
        self.action_routing: Dict[ActionKind, List[str]] = {}
    
    def register_market(self, market: BaseMarket, action_kinds: List[ActionKind]):
        """
        Register a market for specific action types
        
        Args:
            market: Market instance to register
            action_kinds: List of action types this market can handle
        """
        if market.market_id in self.markets:
            raise ValueError(f"Market {market.market_id} is already registered")
        
        self.markets[market.market_id] = market
        market.supported_actions.update(action_kinds)
        
        # Update routing table
        for action_kind in action_kinds:
            if action_kind not in self.action_routing:
                self.action_routing[action_kind] = []
            self.action_routing[action_kind].append(market.market_id)
    
    def unregister_market(self, market_id: str):
        """Remove a market from the registry"""
        if market_id not in self.markets:
            return False
        
        market = self.markets.pop(market_id)
        
        # Remove from routing table
        for action_kind in market.supported_actions:
            if action_kind in self.action_routing:
                if market_id in self.action_routing[action_kind]:
                    self.action_routing[action_kind].remove(market_id)
                if not self.action_routing[action_kind]:
                    del self.action_routing[action_kind]
        
        return True
    
    def route_action(self, action: Action, simulation_state: Dict[str, Any]) -> List[Event]:
        """
        Route action to appropriate market
        
        Args:
            action: Action to route
            simulation_state: Current simulation state
            
        Returns:
            List of events from action execution
        """
        # Handle HOLD action (no routing needed)
        if action.kind == ActionKind.HOLD:
            return []
        
        # Find markets that can handle this action
        market_ids = self.action_routing.get(action.kind, [])
        
        if not market_ids:
            return [Event(
                action_kind=action.kind,
                agent_id=action.agent_id,
                market_id="registry",
                result={},
                success=False,
                error_message=f"No market registered for action {action.kind}"
            )]
        
        # Route to the first available market (can be extended for more complex routing)
        market_id = market_ids[0]
        market = self.markets[market_id]
        
        # Validate action
        is_valid, error_message = market.validate_action(action, simulation_state)
        if not is_valid:
            return [Event(
                action_kind=action.kind,
                agent_id=action.agent_id,
                market_id=market_id,
                result={},
                success=False,
                error_message=error_message
            )]
        
        # Execute action
        try:
            events = market.route(action, simulation_state)
            return events
        except Exception as e:
            return [Event(
                action_kind=action.kind,
                agent_id=action.agent_id,
                market_id=market_id,
                result={},
                success=False,
                error_message=f"Market execution error: {str(e)}"
            )]
    
    def end_of_block_all(self, simulation_state: Dict[str, Any]) -> List[Event]:
        """
        Run end-of-block operations for all markets
        
        Args:
            simulation_state: Current simulation state
            
        Returns:
            List of all events from end-of-block operations
        """
        all_events = []
        for market in self.markets.values():
            try:
                events = market.end_of_block(simulation_state)
                all_events.extend(events)
            except Exception as e:
                # Log error but continue with other markets
                print(f"Error in end_of_block for market {market.market_id}: {e}")
        
        return all_events
    
    def get_all_market_data(self) -> Dict[str, Dict[str, Any]]:
        """
        Get market data from all registered markets
        
        Returns:
            Dictionary mapping market_id to market data
        """
        market_data = {}
        for market_id, market in self.markets.items():
            try:
                market_data[market_id] = market.get_market_data()
            except Exception as e:
                print(f"Error getting market data from {market_id}: {e}")
                market_data[market_id] = {}
        
        return market_data
    
    def get_market(self, market_id: str) -> Optional[BaseMarket]:
        """Get market by ID"""
        return self.markets.get(market_id)
    
    def list_markets(self) -> List[str]:
        """List all registered market IDs"""
        return list(self.markets.keys())
    
    def get_supported_actions(self) -> Set[ActionKind]:
        """Get all action types supported by registered markets"""
        supported = set()
        for market in self.markets.values():
            supported.update(market.supported_actions)
        return supported
    
    def get_registry_summary(self) -> Dict[str, Any]:
        """Get summary of the market registry"""
        return {
            'total_markets': len(self.markets),
            'markets': list(self.markets.keys()),
            'supported_actions': len(self.get_supported_actions()),
            'action_routing': {
                action.name: markets for action, markets in self.action_routing.items()
            }
        }
